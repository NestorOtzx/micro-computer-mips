
00100000000100000111111111111111
00100000000100010000000000000001
10001100000100100000001000000000
10101100000100100000001000000000
00000010000100100100000000101010
00010001000100010000000000000010
00001000000000000000000000000000
00100000000010010000000000000000
00100000000010010000000000000000
00100000000010010000000000000000
00100000000010010000000000001111
10101100000010010000001000000000


Verificar que beq sirva

Hacer que la arquitectura permita switches como entrada

Hacer un codigo que espere por entradas y muestre una salida

Implementar mul en el traductor

Modificar el codigo assembly con mul

Traducir el codigo del proyecto assembly a binario

--Codigo para probar jal---
Entrada:
sw $ra, 0x200($zero)
jal 0x3
addi $t0, $zero, 0x0
addi $t0, $zero, 0x0
sw $ra, 0x200($zero)
jal 0x5
addi $t0, $zero, 0x0
addi $t0, $zero, 0x0
sw $ra, 0x200($zero)
jal 0x0

Salida:
10101100000111110000001000000000
00001100000000000000000000000010
00100000000010000000000000000000
00100000000010000000000000000000
10101100000111110000001000000000
00001100000000000000000000000110
00100000000010000000000000000000
00100000000010000000000000000000
00100000000010000000000000000000
00100000000010000000000000000000
10101100000111110000001000000000
00001100000000000000000000000000

--Codigos para probar jr---

Entrada:
addi $s0, $zero, 0x0
jal 0x3
j 0x7
addi $s0, $s0, 0x1
sw $s0, 0x200($zero)
sw $ra, 0x200($zero)
jr $ra
addi $t0, $zero, 0xf
sw $t0, 0x200($zero)

Salida:
00100000000100000000000000000000
00001100000000000000000000000011
00001000000000000000000000000111
00100010000100000000000000000001
10101100000100000000001000000000
10101100000111110000001000000000
00000011111000000000000000001000
00100000000010000000000000001111
10101100000010000000001000000000

Entrada:
addi $s0, $zero, 0x0
jal 0x5
jal 0x5
jal 0x5
j 0x8
addi $s0, $s0, 0x1
sw $s0, 0x200($zero)
jr $ra
addi $t0, $zero, 0xf
sw $t0, 0x200($zero)

Salida:
00100000000100000000000000000000
00001100000000000000000000000101
00001100000000000000000000000101
00001100000000000000000000000101
00001000000000000000000000001000
00100010000100000000000000000001
10101100000100000000001000000000
00000011111000000000000000001000
00100000000010000000000000001111
10101100000010000000001000000000

Funcion para leer entrada

---Funcion para leer entrada---

Entrada 1:

jal leerTarjeta
j fin
leerTarjeta:
	lui $t0, 0x0008
	addi $t4, $zero, 0x1
while:
	lw $t1, 0x200($zero)
	slt $t3, $t0, $t1
	beq $t3, $t4, 0x1		
	j while			
	sub $v0, $t1, $t0
	jr $ra
fin:
	add $t0, $zero, $v0
	sw $v0, 0x200($zero)

Entrada 2:

jal 0x2
j 0xa
lui $t0, 0x0008
addi $t4, $zero, 0x1
lw $t1, 0x200($zero)
slt $t3, $t0, $t1
beq $t3, $t4, 0x1		
j 0x4
sub $v0, $t1, $t0
jr $ra
add $t0, $zero, $v0
sw $v0, 0x200($zero)

Salida para las 2 entradas (debe esta misma salida en las 2):
00001100000000000000000000000010
00001000000000000000000000001010
00111100000010000000000000001000
00100000000011000000000000000001
10001100000010010000001000000000
00000001000010010101100000101010
00010001011011000000000000000001
00001000000000000000000000000100
00000001001010000001000000100010
00000011111000000000000000001000
00000000000000100100000000100000
10101100000000100000001000000000


valor a traducir 00000000000010000000000000000000

Prueba de lui:

addiu $s0, $zero, 0x8000
sw $s0, 0x200($zero)

00100100000100001000000000000000
10101100000100000000001000000000

Entrada:
lui $s0, 0x1000
sw $s0, 0x200($s0)
ori $s0, $s0, 0x8000
sw $s0, 0x200($s0)

Salida:
00111100000100000001000000000000
10101110000100000000001000000000
00110110000100001000000000000000
10101110000100000000001000000000





const	 entrada
0x7fff   0x8000 = 1 
0x7fff	 0x7fff = 0
0x7fff   0x0000 = 0
















